import{_ as p,E as t,c as r,m as s,a,J as l,w as i,V as e,o,t as c}from"./chunks/framework.YnO4XY28.js";const S=JSON.parse('{"title":"介绍","description":"","frontmatter":{},"headers":[],"relativePath":"guide/mini-app/未命名文件夹/介绍.md","filePath":"guide/mini-app/未命名文件夹/介绍.md","lastUpdated":1732806619000}'),h={name:"guide/mini-app/未命名文件夹/介绍.md"},d=e("",11),u=s("code",null,".wxml",-1),g=s("code",null,".html",-1),k=s("code",null,"wx:if",-1),b=s("code",null,".wxss",-1),m=s("code",null,"rpx",-1),E=s("code",null,"app.wxss",-1),_=s("code",null,"page.wxss",-1),x=s("li",null,[s("code",null,".js"),a(" 作为跟页面交互角色，在小程序开发中也不例外。在 "),s("code",null,"js"),a(" 中，可以使用微信提供的API。比如常见的 Page（构造器）和 Component，还有微信给出的一些特定权限的API（wx.navigateTo）。")],-1),v=s("li",null,[s("code",null,".json"),a(" 是配置文件，在小程序中JSON扮演者静态配置的角色。")],-1),y=e("",36);function f(q,w,A,P,j,C){const n=t("font");return o(),r("div",null,[d,s("ul",null,[s("li",null,[u,a(" 模版文件对应为传统网页开发技术中的 "),g,a(" 文件，是一个页面（组件）的骨架。只不过它里面采用的语法跟传统的 HTML 语法有些差异，比如标签的名称是微信自己在底层封装的组件。 "),s("ul",null,[s("li",null,[s("strong",null,[l(n,{color:"red"},{default:i(()=>[a("标签名字有点不一样")]),_:1})]),a("。在写HTML的时候，经常会用到的标签是 div、p、span，小程序的 WXML 用的标签是 view、button、text等等，这些标签是小程序给开发者包装好的基本能力，小程序还提供了地图、视频、音频等组件能力。")]),s("li",null,[s("strong",null,[l(n,{color:"red"},{default:i(()=>[a("多了一些 "),k,a(" 这样的属性以及 "),s("code",null,c(),1),a(" 这样的表达式")]),_:1})]),a("。微信小程序借鉴了 MVVM 的开发模式（例如React、Vue），把渲染和逻辑分离。简单来说就是不再让JS直接操控DOM，JS只需要管理状态即可，然后再通过一种模版语法来描述状态和界面架构的关系。")])])]),s("li",null,[b,a(" 样式文件则对应CSS样式文件，具有大部分CSS的特性。 "),s("ul",null,[s("li",null,[s("strong",null,[l(n,{color:"red"},{default:i(()=>[a("新增了尺寸单位")]),_:1})]),a("。在写CSS样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。WXSS在底层支持新的尺寸单位 "),m,a("，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。")]),s("li",null,[s("strong",null,[l(n,{color:"red"},{default:i(()=>[a("采用了全局的样式和局部样式")]),_:1})]),a("。根目录中的 "),E,a(" 为项目公共样式，它会被注入到小程序的每个页面，局部页面样式 "),_,a(" 仅对当前页面生效。")])])]),x,v]),y])}const T=p(h,[["render",f]]);export{S as __pageData,T as default};
