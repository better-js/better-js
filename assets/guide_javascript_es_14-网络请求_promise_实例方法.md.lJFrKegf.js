import{_ as s,c as i,o as a,V as e}from"./chunks/framework.YnO4XY28.js";const g=JSON.parse('{"title":"实例方法","description":"","frontmatter":{},"headers":[],"relativePath":"guide/javascript/es/14-网络请求/promise/实例方法.md","filePath":"guide/javascript/es/14-网络请求/promise/实例方法.md","lastUpdated":1732283740000}'),n={name:"guide/javascript/es/14-网络请求/promise/实例方法.md"},l=e(`<h1 id="实例方法" tabindex="-1">实例方法 <a class="header-anchor" href="#实例方法" aria-label="Permalink to &quot;实例方法&quot;">​</a></h1><h2 id="promise-prototype-then" tabindex="-1">Promise.prototype.then() <a class="header-anchor" href="#promise-prototype-then" aria-label="Permalink to &quot;Promise.prototype.then()&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>语法：<code>then(onFulfilled, onRejected)</code></p><p>参数：</p><ul><li>onFulfilled <em>[可选]</em><ul><li>一个在此 Promise 对象被兑现时异步执行的函数。它的返回值将成为 <code>then()</code> 返回的 Promise 对象的兑现值。此函数被调用时将传入以下参数： <ul><li><code>value</code>：Promise 对象的兑现值。</li></ul></li><li>如果 <code>onFulfilled</code> 不是一个函数，则内部会被替换为一个<em>恒等</em>函数（<code>(x) =&gt; x</code>），它只是简单地将兑现值向前传递。</li></ul></li><li>onRejected <em>[可选]</em><ul><li>一个在此 Promise 对象被拒绝时异步执行的函数。它的返回值将成为 <code>catch()</code> 返回的 Promise 对象的兑现值。此函数被调用时将传入以下参数： <ul><li><code>reason</code>：Promise 对象被拒绝的原因。</li></ul></li><li>如果 <code>onRejected</code> 不是一个函数</li></ul></li></ul><p>返回值：立即返回一个新的 <code>Promise</code> 对象，该对象始终处于待定状态</p></div><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;成功！&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 或</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //   reject(new Error(&quot;错误!&quot;));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&gt;&gt;&gt;value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, value); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 成功！</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reason</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&gt;&gt;&gt;reason&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, reason); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误！</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="promise-prototype-catch" tabindex="-1">Promise.prototype.catch() <a class="header-anchor" href="#promise-prototype-catch" aria-label="Permalink to &quot;Promise.prototype.catch()&quot;">​</a></h2><p><code>Promise</code> 实例的 <strong><code>catch()</code></strong> 方法用于注册一个在 promise 被拒绝时调用的函数。它会立即返回一个等效的 <code>Promise</code>对象，这可以允许你链式调用其他 promise 的方法。此方法是 <code>Promise.prototype.then(undefined, onRejected)</code>的一种简写形式。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>语法：<code>catch(onRejected)</code></p><p>参数：</p><ul><li>onRejected <ul><li>一个在此 Promise 对象被拒绝时异步执行的函数。它的返回值将成为 <code>catch()</code> 返回的 Promise 对象的兑现值。此函数被调用时将传入以下参数： <ul><li><code>reason</code>：Promise 对象的拒绝值。</li></ul></li></ul></li></ul><p>返回值：返回一个新的 <code>Promise</code>，无论当前的 promise 状态如何，这个新的 promise 在返回时总是处于待定状态。如果 <code>onRejected</code> 方法抛出了一个错误或者返回了一个被拒绝的 promise，那么这个新的 promise 也会被拒绝；否则它最终会被兑现。</p></div><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;出错了!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(error);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="promise-prototype-finally" tabindex="-1">Promise.prototype.finally() <a class="header-anchor" href="#promise-prototype-finally" aria-label="Permalink to &quot;Promise.prototype.finally()&quot;">​</a></h2><p><code>Promise</code> 实例的 <strong><code>finally()</code></strong> 方法用于注册一个在 promise 敲定（兑现或拒绝）时调用的函数。它会立即返回一个等效的 <code>Promise</code> 对象，这可以允许你链式调用其他 promise 方法。</p><p>这可以让你避免在 promise 的 <code>then()</code> 和 <code>catch()</code> 处理器中重复编写代码。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>语法：<code>finally(onFinally)</code></p><p>参数：</p><ul><li>onFinally <ul><li>一个当 promise 敲定时异步执行的函数。它的返回值将被忽略，除非返回一个被拒绝的 promise。调用该函数时不带任何参数。</li></ul></li></ul><p>返回值：返回等效的 <code>Promise</code>。如果处理程序抛出错误或返回被拒绝的 promise，那么 <code>finally()</code> 返回的 promise 将以该值被拒绝。否则，处理程序的返回值不会影响原始 promise 的状态。</p></div>`,12),p=[l];function t(h,r,k,o,d,c){return a(),i("div",null,p)}const m=s(n,[["render",t]]);export{g as __pageData,m as default};
