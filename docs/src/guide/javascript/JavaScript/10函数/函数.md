# 函数



## 构造函数

构造函数以大写字母开头，并且以它们创建的对象类型命名

构造函数只是使用 `new` 关键字调用的函数。当你调用构造函数时，它将：

- 创建一个新对象
- 将 `this` 绑定到新对象，以便你可以在构造函数代码中引用 `this`
- 运行构造函数中的代码
- 返回新对象

```js
function Person(name) {
  this.name = name;
  this.introduceSelf = function () {
    console.log(`你好！我是 ${this.name}。`);
  };
}

const salva = new Person("Salva");
salva.name;
salva.introduceSelf();
// "你好！我是 Salva。"

const frankie = new Person("Frankie");
frankie.name;
frankie.introduceSelf();
// "你好！我是 Frankie。"
```





## 为什么需要函数

函数可以**实现代码复用**，提高开发效率。



## 函数介绍

- 函数：function，是被设计在特定时机可以重复执行特定任务的代码段

- 说明：
  - 函数可以把具有相同或相似逻辑的代码“包裹”起来，通过函数调用执行这些被“包裹”的代码逻辑，这么做的优势是有利于精简代码方便复用。

## 函数使用

建议按照先声明后调用的顺序

- 函数的声明语法

  ```javascript
  function 函数名（参数）{
  	函数体：你希望能重复使用的代码
  }
  
  注意：
  	参数可以省略
  ```

- 函数的调用语法

  ```javascript
  函数名()
  
  注意：
  	声明（定义）的函数必须调用才会真正被执行，使用函数名()调用函数
  ```

- 函数名命名规范：

  - 和变量命名基本一致

  - 尽量小驼峰式命名法

  - 前缀应该为动词

  - 命名建议：常用动词约定

    | 动词 | 含义                     |
    | ---- | ------------------------ |
    | can  | 判断是否可以执行某个动作 |
    | has  | 判断是否含有某个值       |
    | is   | 判断是否为某个值         |
    | get  | 获取某个值               |
    | set  | 设置某个值               |
    | load | 加载某些数据             |

- 循环和函数的区别

  - 循环：写完之后，立即执行
  - 函数：只有调用，才会执行，并且只要声明的函数，可以在任意位置调用。

- 函数的总结

  - 函数在声明之后,是不会执行里面的代码,需要手动的调用才行
  - 函数一旦声明之后,就可以在任意位置调用
  - 函数的调用没有次数限制,没有上限,完全取决于你的需求



## 带参函数

函数传参的好处是可以极大的提高函数的灵活性，功能更加强大

如果在重复使用代码的时候，可能有一些会发生变化的数据，就要使用参数。

- 声明语法：

  ```javascript
  function 函数名（形参）{
  	函数体
  }
  ```

- 调用语法：

  ```javascript
  函数名（实参）
  ```

  

- 形参与实参

  - 形参：声明函数时写在函数名右边小括号里的叫形参（形式上的参数）
  - 实参：调用函数时写在函数名右边小括号里的叫实参（实际上的参数）

  形参可以理解为是在这个函数内声明的变量，实参可以理解为是给这个变量赋值（比如num1=10）

  

  实参<形参的数量时，不会报错，但会给未传值的数据补一个undefined

  

  实参>形参的数量时，啥事没有，只会保留对应的个数，多的不赋值

  

  - 如何获取全部实参，可以使用函数内部提供的方法：**`arguments`** 功能就是帮助我们获取函数在调用的时候，全部的实参

    - arguments是一个伪数组，有索引和长度

    - 注意事项

      - 函数自带的，不需要声明
      - **只能在函数的内部使用**
      - 可以得到函数在实际调用时全部的实参

      ```javascript
      //当实参数量大于形参的数量时，赋值一一对应，多出的不赋值，通过函数内部自带的arguments实现获取全部实参
      function getSum(num1,num2){
        console.log(arguments)
        let sum=0
        for(let i=0;i<arguments.length;i++){
          sum+=arguments[i]
        }
        alert(sum)
      }
      
      getSum(1,3,4,5,6,8,9)  //36
      
      //当实参数量小于形参的数量时，结果为NaN
      function getSum(a,b,c){
        /* 逻辑或 添加默认值*/
        a = a || 0
        b = b || 0
        c = c || 0
        return a + b + c
      }
      
      console.log(getSum(1,3))  //4 
      ```

## 函数返回值

当函数需要返回数据出去时，用return关键字

```javascript
//return返回一个值
return 返回值

//return返回多个值
return [返回值1,返回值2]

细节：
	在函数体中使用return关键字能将内部的执行结果交给函数外部使用
	函数内部只能出现1次return，并且return后面代码不会再被执行，所以return后面的数据不要换行写
	return会立即结束当前函数，后面的代码不在执行
	函数没有return，这种情况函数默认返回值为undefined
```

- return的作用
  - 修改函数的返回值
  - 终止函数的运行



## 作用域

### 1. 变量污染

- 作用域就是变量和函数的有效范围，作用域可以防止变量污染
  - 如果在全局作用域中，一个出现同名的变量或者函数，后面就会覆盖前面的变量
  - 学名叫做：**变量污染** 同名变量 后面的覆盖前面的
  - 为了防止变量污染，规定一个范围，把它们隔绝起来，那么这个范围就被称为作用域

### 2. 函数作用域

通常来说，一段程序代码中所用到的名字并不总是有效和有用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。

- **全局作用域**：全局有效，作用于所有代码执行的环境（整个script标签内部）或者一个独立的js文件
- **局部作用域**：局部有效，作用于函数内的代码环境，就是局部作用域。因为跟函数有关系，所以也称为函数作用域。
- **块级作用域**：{}内有效，块作用域由{}包括，if语句和for语句里面的{}等



### 3. 变量的作用域

在JavaScript中，根据作用域的不同，变量分为

- **全局变量**：函数外部let的变量，全局变量在任何区域都可以访问和修改
- **局部变量**：函数内部let的变量，局部变量只能在当前函数内部访问和修改
- 块级变量：{}内部的let变量，let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问

- 变量有一个坑，特殊情况：

  - **如果函数内部或者块级作用域内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐。**
  - 但是有一种情况，函数内部的形参可以看做是局部变量，出了函数就无效了，不能使用。

### 4. 变量的访问原则-作用域链

- 只要是代码，就至少有一个作用域
- 写在函数内部的局部作用域
- 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域
- 根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。
  - 作用域链：采取就近原则的方式来查找变量最终的值

## 匿名函数

- 具名函数：

  ```javascript
  //声明：
  function fn(){}
  
  //调用：
  fn()
  ```

- 匿名函数：

  ```javascript
  function(){}
  
  //将匿名函数赋值给一个变量，并且通过变量名称进行调用，我们将这个称为函数表达式。
  语法：	
  	let fn=function(){
  		函数体
  	}
  
  调用：
  	fn()  
  ```

- 立即执行函数（自调用函数）

  ```javascript
  //使用场景：避免全局变量之间的污染
  语法1:
  	(function (){  })();
  
  语法2:
  	(function (){  } ());
  	
  不需要调用，立即执行
  注意：多个立即执行函数要用；隔开，要不然会报错。
  ```

  - 推导过程：

    ```javascript
    声明：
    	let fn=function(形参){}
    
    调用：
    	fn(实参)
    
    推导：
    	function(形参){}(实参)	 	
    	(function(形参){})(实参)	 
    	(function(形参){}(实参))
    ```

- 函数传值赋值小技巧

  ```java
  //为形参添加默认值,防止NaN
  //形参不赋值，系统默认补一个undefined
  //数字+undefined  会报NaN
  声明：
  	let fn=function(x,y){
  		x=x||0
  		y=y||0
  		console.log(x+y)
  	}
  
  或者
  	let fn=function(x=0,y=0){
  		console.log(x+y)
  	}
  
  调用：
  	fn()
  	fn(3,5)
  ```


## 副作用函数

在开发过程中，我们经常需要写一些函数来完成特定的任务。这些函数可能会接收一些输入（我们称之为形参），然后根据这些输入计算出一个结果并返回，这就是函数的基本作用。

然而，有些函数除了返回结果之外，还会做一些额外的事情，比如改变一些在函数外部也可以访问的变量的值，或者读写文件，或者在屏幕上打印一些内容等等，这些额外的事情，我们称之为**副作用**。

举个例子，假设我们有一个函数，它的任务是计算两个数的和：

```js
function sum(x, y) {
  return x + y;
}
```

这个函数就是一个没有副作用的函数，应为它只做了一件事：计算两个数的和并返回结果。它没有改变任何外部的东西，也没有做其他的事情。

但是，我们稍微改变一下这个函数：

```js
let total = 0;
function sum(x, y) {
	total = total + x + y;
  return total;
}
```

这个新的函数就有了副作用了，因为除了返回了两个数的和之外，它还改变了一个叫做 `total` 的变量的值。这个 `total` 变量是在函数外部定义的，所以这个函数的副作用就是改变了 `total` 的值。

这就是副作用函数的概念。在开发中，有时候我们需要使用副作用函数，但是过多的副作用函数会使得代码变得难以理解和维护，所以我们通常会尽量减少副作用函数的使用。
