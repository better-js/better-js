## console.log(0.1 + 0.2) （掌握）

0.1+0.2的结果不是0.3，而是0.3000000000000000004，JS中两个数字相加时是以二进制形式进行的，当十进制小数的二进制表示的有限数字超过52位时，在JS里是不能精确储存的，这个时候就存在舍入误差。



## 事件冒泡和事件捕获到底有何区别？（掌握）

- 事件冒泡：从下至上。当给有层级关系的元素的同一事件绑定方法时，触发子元素身上的事件，会像冒泡一样，依次触发父级元素相同的事件。
- 事件捕获：从上至下到指定元素。当触发子元素身上的事件时，先触发父元素，然后在传递给子元素
- 注意：addEventListener中有三个属性，第三个属性是布尔值。false为事件冒泡，true为事件捕获。



## JS数据类型（掌握）

- ES5：Number、String、Boolean、null、undefine

- ES6：Symbal



## 简述javascript原型、原型链？有什么特点（掌握）

- 原型
  - 原型是针对函数而言的，构造函数也是一个函数。
  - 在JS中，我们创建的每一个函数自带一个属性prototype，这个prototype就称之为原型，它是函数的独有属性。prototype指向一个对象，这个对象就是原型对象，原型对象内有个constructor属性，它指向当前的构造函数。

- 原型链
  - 每一个实例对象都有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有一个 __proto__属性，指向它的构造函数的原型对象，这样一层一层往上找就形成了原型链。

- 特点：
  - 原型和原型链巧妙地解决了js中实现继承的问题
  - 实现继承：一个对象可以拿到另一个对象上的属性和方法，实现了数据共享、节省内存空间。



## 谈谈this对象的理解，call()、apply()和bind()的区别（掌握）

- this指向
  - 全局作用域中this指向window
  - 函数作用域中this指向window
  - 在事件绑定中的this指向事件源
  - 当一个对象调用一个函数时，函数内的this指向的是这个对象
  - 箭头函数内部  this指向了当前作用域的最近一级外层作用域
  - new关键字将函数作为构造函数调用时，构造函数内部的this指向新创建的对象。
- call
- apply
- bind

call()和apply()的作用就是改变this的指向，它俩都是立即执行的。

call()可以传入多个参数，第一个参数是this的指向，其余参数是要传入的参数，call必须一次性传入所有参数。

apply可以传入两个参数，第一个参数是this的指向，第二个参数是一个参数数组



## 什么是闭包？为什么要用它？（掌握）

闭包本质就是一个函数，它是指能够读取其他函数内部变量的函数，它是将函数内外部连接起来的桥梁。只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数”。

闭包的主要作用：实现了数据的私有化，延伸了变量的作用范围。



## 简述js继承的方式（掌握）

- 混入式继承：把父类的所有方法都拷贝到子类上
- 原型式继承：只继承父类原型上的属性和方法，
- 原型链继承：继承父类构造函数里边的属性和方法，也继承父类原型上的属性和方法 缺点--不能向父类传参数
- 借用构造函数继承：可以父类传递参数 缺点--继承不了父类原型对象的方法
- 组合继承：借用构造函数继承属性+原型链继承方法



## 深拷贝和浅拷贝的区别（掌握）

- 深拷贝拷贝多层，每一级别的数据都会拷贝，像数组、对象内的数据都是可以拷贝的。
- 浅拷贝只是拷贝一层，像简单数据类型可以直接拷贝，更深层次对象级别的只拷贝对象引用地址（修改对象内的属性值会相互影响）
- es6新增方法可以浅拷贝：Object.assign(新对象,被拷贝对象)    



## 如何实现深拷贝（掌握）

```js
let obj = {}
// 将对象转为字符串
let str = JSON.stringify(obj)
// 深拷贝
let nstr = str
// 将字符串转为数组
let nobj = JSON.parse(nstr)

//变成一行  深拷贝的方法
let nnobj = JSON.parse(JSON.stringify(obj))
```



## javascript 的垃圾回收机制讲一下（掌握）

- 垃圾回收机制（Garbage Collection）简称GC
- JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。
- 垃圾回收机制会自动在后台进行检查，哪些内存空间是已经没有被变量绑定的，如果存在就会标记它们，在垃圾回收执行时去释放这些标记好的内存空间的地址，这个释放并不是删除，而是告诉CPU哪些空间是可以用的，后续有新数据便会存入到里面，进行覆盖。
- 不再用到的内存，没有及时释放，就叫做内存泄露。垃圾回收机制就是防止内存泄漏的。





## 请描述一下 cookies，sessionStorage 和 localStorage 的区别？

- cookie是网站为了标示用户身份而存储在用户本地终端上的数据，是加密的。
- cookie数据始终在同源的http请求中携带，会在浏览器和服务器间来回传递。
- sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存

- 存储大小
  1. cookie数据大小不能超过4kb
  2. sessionStorage和localStorage可以达到5M或更大
- 有效时间
  1. cookie可以设置过期时间，在没过期之前，一直有效，不会因窗口或浏览器的关闭受到影响
  2. sessionStorage数据在当前浏览器窗口关闭后自动删除
  3. localStorage浏览器关闭后数据不丢失，可以持久存储数据，除非手动删除



localStorage -- 是永久存储在本地，除非你主动去删除;

sessionStorage -- 是存储到当前页面关闭为止，和其他tab页没关联;

cookie -- 则根据你设置的有效时间来存储，但缺点是不能储存大数据且不易读取，会和后台进行交互。

本方法选择的是sessionStorage，选择的原因是由于vue是单页面应用，操作都是在一个页面跳转路由，另一个原因是sessionStorage可以保证打开页面时sessionStorage的数据为空，而如果是localStorage则会读取上一次打开页面的数据。



## 简述同源策略与跨域（掌握）

同源策略是一种约定，它是浏览器最核心的也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能会受到影响。

当协议，主机，和端口号有一个不同时，就是跨域。



## 跨域解决方案（掌握）

- 网站跨域问题一般发生在前后端分离的架构。
- 解决方案
  1. 前后端部署到同一台web服务器，实现了同源策略。
  2. （后端）服务器配置CORS(跨域资源共享)
  3. （后端）node.js或Nginx，反向代理，把跨域改造成同域
  4. （前端）将JSON升级成JSONP，在JSON的基础上，利用script 标签可以跨域的特性，加上头设置



## 浏览器的事件循环（掌握）

- 主线程不断的重复获得任务，执行任务的过程被称为浏览器的事件循环。
- JS语言特点是单线程，解释性语言，解释一行执行一行，也就是说同一时间只能做一件事。
  单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就得一直等待。
- JS将所有任务分成两种，一种是同步任务，另一种是异步任务，异步任务又分为两种，宏任务和微任务。先执行宏任务，再执行微任务。
  - 同步任务指的是，在主线程中排队执行的任务，按序执行，只有前一个任务执行完毕，才能执行后一个任务；
  - 异步任务指的是，不进入主线程，而进入“任务队列”的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。



## 什么是防抖和节流？有什么区别？如何实现？（掌握）

- 防抖或节流：通过一定的方式去限制函数的执行次数
- 防抖：通过setTimeout的方式，在一定的时间间隔内，将多次触发变成一次触发。如果设定的时间还没到来之前，又一次触发了事件 ，则清除之前的定时器，就重新开始延时。
- 节流：在一段时间内，只执行一次某个操作；过了这一段时间，还有操作的话，继续执行新的操作

- 区别:
  - 节流不管事件触发多频繁，都保证在一定时间内一定会执行一次函数。防抖是只在最后一次事件触发后才会执行一次函数
- 实现：
  - 防抖：每次触发事件时设置一个延时调用方法，并且取消之前的延时调用方法。
  - 节流：每次触发事件的时候，判断当前是否存在等待执行的延时函数





## 为什么会有token？

```
安全和方便

1）前端向后端获取数据，后端如果不需要验证前端的身份，谁都可以获取，就不需要token

2）需要验证身份，也就是需要前端账号和密码，每次都验证账号和密码太麻烦和耗时了，是重复工作，减轻服务器的压力，减少频繁的查询数据库

3）如果用用户的id作为交互的凭证，那么谁拿到这个id任何时候都可以和后端交互，有很大安全隐患

所以前端请求后端时，后端根据用户信息，随机数，时间戳等特定信息进行加密和拼接，最终生成token字符串。
这个token就可以证明你是哪个用户，是什么时候登录的，之后和前端交互就只通过验证token就知道这是不是刚才那个用户。

简单说就是：
1）前端拿着token令牌向后端要东西；
2）后端匹对令牌是否有权限；
3）给东西或拒绝
```



## 箭头函数

```
箭头函数是ES6中新加入的语法，它不同于传统的函数，箭头函数并没有属于自己的this，它所谓的this是捕获其所在上下文的this，作为自己的this值，并且由于没有属于自己的this，所以是不会被new调用的，这个所谓的this也不会被改变。

1）箭头函数没有自己的this

2）箭头函数继承来的this指向永远不会改变

3）call()、apply()、bind()等方法不能改变箭头函数中this的指向

4）箭头函数不能作为构造函数使用

5）箭头函数没有原型prototype

6）箭头函数没有自己的arguments
```





## 同步与异步

```
所谓的同步任务是指程序在运行的时候，所有任务需要进行排队，当前一个任务执行完，才执行下一个任务。这样就产生了一个问题，如果前一个任务的耗时比较长，后续的任务则需要等待前一个任务完成，从而阻塞代码的运行。
而异步任务则是指程序在运行的时候，如果前一个任务比较耗时，并不会等待这次的任务返回结果，而是继续去执行后续的任务。当前一个任务结果返回以后，再去执行相关的这个任务。异步任务很好的解决了代码运行中得到阻塞问题
```

## 事件循环机制

```
假如需要对一段js代码进行执行解析，那么在解析的时候，会先将整体的代码压入到Call Stack（调用栈）进行执行。
如果是同步的任务，调用栈会将代码放到主线程中，在主线程中依次对代码进行执行。
如果是异步的任务，并不会立即执行，而是会将代码放到Event Table(可以理解为用来存储异步任务极其对应回调函数的列表)中，这个过程中也会调用执行环境的API，如果在浏览器中就会调用相关的Web API，当对应的事件（或AJAX，或定时器）触发以后，Event Table会将事件对应的回调函数移入消息队列中等待。
```







## 节流

```
节流会减少一段时间内事件的触发频率，从而解决网络资源
场景：
轮播图按钮
上拉加载

```

## 防抖

```
所谓的防抖是指，触发高频事件后N秒内函数只会执行一次，如果N秒内高频事件再次被触发，则重新计算时间。说白了，就是在一定的时间期限内，对应的事件处理只执行一次。
场景：
王者荣耀的回城效果
搜索框输入，不能让用户每次输入时都发送请求，等用户输入完成再去发送请求，这样有效的减少了请求次数，节约了网络资源
```

## new一个对象的执行过程

```js
function Person(name){
 this.name = name
}
const andy = new Person('andy')

new一个对象，它的内部经历了4步：
1.创建一个新的空对象
const obj = {}
2.新对象的__proto__指向构造函数Person的原型对象
obj.constructor = Person
obj.__proto__ = Person.prototype
3.构造函数里面的this指向新对象
Person.call(obj)
4.返回新对象
```

## 

## JS类型判断，说出多种数组判断方法

第1种

```js
//通过原型链判断
obj.__proto__ === Array.prototype
```

第2种 

```js
//通过isArray判断
Array.isArray(obj)
```

第3种

```js
//通过instanceOf判断
obj instanceOf Array
```

第4种

```js
//通过Array.prototype.isPrototypeOf
Array.prototype.isPrototypeOf(obj)
```

第5种

```js
//通过Object.prototype.toString.call()做判断
Object.prototype.toString.call(obj).slice(8, -1) === "Array"
```



## 一串大数字转成 xxx,xxx,xxx 这种间隔的方法

```js
let num = 123456789;
let numtostr = num.toString()
let str = ''
for(let i=numtostr.length-1;i>=0;i--){
  if((str.length+1)%4==0){
    str=','+str;
    i++
  }else{
    str = numtostr[i]+str
  }
}
console.log(str)
```



## 在JavaScript中什么是堆，什么是栈，它们有什么联系和区别

```
（1）内存操作场景下，堆与栈表示两种内存的管理方式。
栈由操作系统自动分配和释放，用于存放简单的数据段，占据固定大小的空间，比如基本数据类型（Number、String、Boolean……）和函数的参数值等。

堆由开发人员自主分配和释放，若不主动释放，程序结束时由浏览器回收，用于存储引用类型（引用类型的变量实际上保存的不是变量本身，而是指向内存空间的指针）。

（2）数据结构场景下，堆与栈表示两种常用的数据结构。
JavaScript存在栈和队列概念，通过数组的方式，模仿实现堆栈。

栈：栈是一种运算受限的线性表，其限制是指只仅允许在表的一端进行插入和删除操作，这一端被称为栈顶（Top），相对地，把另一端称为栈底（Bottom）。把新元素放到栈顶元素的上面，使之成为新的栈顶元素称作进栈、入栈或压栈（Push）；把栈顶元素删除，使其相邻的元素成为新的栈顶元素称作出栈或退栈（Pop）。通过数组的push()、pop()方法实现栈。

堆：堆其实是一种优先队列，也就是说队列中存在优先级，比如队列中有很多待执行任务，执行时会根据优先级找优先度最高的先执行。
```



## 在数据结构中栈的存储方式是什么？

```
数组（顺序存储）和链表（链式存储）
```



## JavaScript中ES6有了解么? ES5和ES6各有什么区别么？

```
ES6新特性
1.let、const
2.模版字符串
3.解构语法
4.箭头函数
5.函数参数设置默认值
6.扩展运算符和...rest
7.Promise
8.对象简写
```



## 那ES6相对于ES5增加了哪些数据类型呢？

```
Symbol 类型（基本）
Set 类型（复杂）
Map 类型（复杂）
WeakSet 类型（复杂）
WeakMap 类型（复杂）
TypedArray 类型（复杂）
```



## 在JS中如何判断某个对象是否属于某个类呢？

```js
instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上。

function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
const auto = new Car('Honda', 'Accord', 1998);

console.log(auto instanceof Car);	// true
console.log(auto instanceof Object);	// true
```



## 什么时候会发生布尔值的隐式类型强制转换

```
1. if(..)语句中的条件表达式
2. for(..;..;..)语句中的第二个条件判断表达式
3. while(..)和do(..)while(..)循环中的条件判断表达式
4. ?:中的条件判断表达式
5. 逻辑运算符 || 和 && 左边的操作数
```



## 在Js中哪些操作会引起内存泄漏

```
1. 意外声明的全局变量
2. 闭包引起的内存泄漏
3. 没有清理的DOM元素的引用
4. 被遗忘的定时器或回调
5. 控制台日志 console.log
```



## 内存泄漏会造成什么后果

```
1. 什么事内存泄漏
	由于疏忽或错误造成程序未能释放已经不再使用的内存，不再用到的内存没有及时释放，从而造成内存上的浪费
2. 内存泄漏的后果
	内存泄漏会造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等
3. 怎样避免内存泄漏
	a.减少不必要的全局变量，及时对无用的数据进行垃圾回收
	b.注意程序逻辑，避免“死循环”之类的
	c.避免创建过多的对象
```



## 能简单介绍一下js的节流和防抖么

```
防抖：通过setTimeout的方式，在一定的时间间隔内，将多次触发变成一次触发。如果设定的时间还没到来之前，又一次触发了事件 ，则清除之前的定时器，就重新开始延时。

节流：在一段时间内，只执行一次某个操作；过了这一段时间，还有操作的话，继续执行新的操作
```



## js中如何检测一个对象是空对象

```
1.将对象转换成字符串，再判断是否等于“{}”
	JSON.stringify(obj)==='{}'
2. Object.keys()方法，返回对象的属性名组成的一个数组，若长度为0，则为空对象【ES6写法】
	Object.keys(obj).length===0
```



## 能简单解释一下原型和原型链的关系么

```
原型和原型链巧妙地解决了js中实现继承的问题

- 原型
	原型是针对函数而言的，构造函数也是一个函数
	在JS中，我们创建的每一个函数自带一个属性prototype，这个prototype就称之为原型，它是函数的独有属性
	prototype指向一个对象，这个对象就是原型对象，原型对象内有个constructor属性，它指向当前的构造函数

- 原型链
	每一个实例对象都有一个__proto__属性，指向它的的构造函数的原型对象，构造函数的原型对象也是一个对象，也有一个__proto__属性，这样一层一层往上找就形成了原型链。

- 作用：
	数据共享、节省内存空间
	实现继承

```



## 我能修改prototype上的属性么

```
在js中并不能直接修改内置类的prototype，但是可以通过修改prototype的属性达到修改内置类行为的目的。
```



## 你简单说一下从浏览器输入url到页面渲染发生了什么？

```
1. 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；
2. 服务器交给后台处理完成后返回数据，浏览器接收文件（html，js，css，图像等）;
3. 浏览器对加载到的资源（html，js，css等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）;
4. 载入解析到的资源文件，渲染页面，完成。
```



## 我如果有一个构造函数，我bind了一个对象，然后我用构造函数创建出的实例会继承这个对象的属性吗？为什么？

```
不会继承。因为根据this绑定四大规则，new绑定的优先级高于bind显示绑定，通过new进行构造函数调用时，会创建一个新对象，这个新对象会代替bind的对象绑定，作为函数的this，并且在此函数没有返回对象的情况下，返回这个新建的对象
```



## 能简单说一下js里面为什么有深拷贝么？





## 平常用过什么好用的js库

```
Lodash
Lodash-es
```



## 你有用过Lodash-es么

```
lodash为了良好的浏览器兼容性, 它使用了旧版es5的模块语法; 
而lodash-es则使用了es6的模块语法
```



## git分支解决冲突你是怎么解决的

```

```



## 防抖和节流

### 

## cookie、web storage、indexedDB

### 

## 数组去重

```js
let arr = [1, 3, 3, 2, 1, 1, 5, 6, 7];

// 方法一
let brr = [...new Set(arr)];
console.log(brr);
// 方法二
arr.filter((item,index,self)=>{
  // 获取元素在数组中第1次出现的下标
  return self.indexOf(item) == index
})
```



## 数组求和

```js
let arr = [1,2,3,4]

let brr = arr.reduce((pre,current)=>{
  return pre+current
},0)
```



## map和filter的区别

map是数组的遍历，可以对每个元素进行相同的操作

filter是数组过滤，满足条件的数组会组成新数组



## let arr = [1,2,3,4] 变成 let brr = [2,4,6,8]

```js
let arr = [1, 2, 3, 4];

let brr = arr.map((item) => {
  return item * 2;
});
console.log(brr);
```















